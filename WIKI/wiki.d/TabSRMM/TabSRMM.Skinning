version=pmwiki-2.2.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0b8pre) Gecko/20101028 Firefox/4.0b8pre Firefox/4.0b8pre
author=admin
charset=UTF-8
csum=
ctime=1287786722
host=81.217.70.206
name=TabSRMM.Skinning
rev=11
targets=TabSRMM.TabSRMM,TabSRMM.Theme,Plugins.IEView,TabSRMM.History,Plugins.HistoryPP,TabSRMM.InputArea,TabSRMM.UsingSkins,TabSRMM.SkinningFormat,TabSRMM.ColorThemes,Category.TabSRMM
text=(:title Skins in TabSRMM 3:)%0a%3c|[[TabSRMM.#skinning|Skinning Index]]|>%0a=Skinning tabSRMM - how it works=%0a[[#teaser]]%0aBeginning with version 1.0, tabSRMM introduced a simple skinning engine. This allows the user to customize the look of the entire message window by using a skin. Usually, a skin consists of the following elements:%0a%0a* images (supported are PNG images in 32bit RGBA format only, this allows full per-pixel alphablending)%0a* a skin definition file. This is an ordinary plain text file. The syntax is compatible with the well-known .INI - Format.\\\%0a%0aTypically, all files must be placed into a single directory. There are basically no restrictions where to put the files, but because the skinning engine is only using relative paths, the images must be at or below the folder in which the skin definition file is placed. The basic rule of **one skin per phyical directory** is important to understand. You cannot mix files from 2 different skin within the same directory.%0a%0aAdvanced skinning techniques allow to use only a single image file. Skin elements are then created by "extracting" rectangular areas from that image file.%0a[[#teaserend]]%0a==Themes vs. skins==%0a%0aOne thing a user should understand is the difference between a [[Theme|theme]] and a skin. A theme is a set of font-, template- and color definitions which determine the look and layout of the text areas inside the message window. A theme does %25red%25not%25%25 alter the look of other message window elements, like title bar, buttons or the status bar.%0a%0a* Themes are files with the extension '''.tabsrmm'''. They can be manually written, but the preferred method is to use the %25green%25'''export message log settings'''%25%25 feature of tabSRMM. This will collect and export all settings which compose a theme and save them to a '''.tabsrmm''' file. Such a file can later be imported again.%0a%0a* Skin definition files have the extension '''.tsk''' and basically they define the rules how the various user interface elements should look like. A skin can optionally include a theme which will be imported when the skin is loaded. This allows users to create a complete customization pack, consisting of a skin and a matching theme.%0a%0a== Skins, themes and how they work with other plugins like IEView ==%0a%0a[[Plugins/IEView|IEView]] is a very popular addon for Miranda. When it is used and active for a message window, it will replace the default message log. Consequently, TabSRMM themes will not work when IEView is in use. Read the page about the [[History|message history]] for further information. Skins will however continue to work, because IEView only replaces the message log area but not the entire message window.%0a%0aSimilarly, when using [[Plugins/HistoryPP|History++]] to display the message history, the same applies.%0a%0a==Which elements are skinable?==%0a%0a* tabs (and the tab page itself)%0a* the container background%0a* the info panel background%0a* the window frame and title bar%0a* the title buttons%0a* the status bar background%0a* the status bar panels (the content rectangles which hold the text or icons)%0a* the surrounding regions of the 2 text areas ([[History|message history]] and [[InputArea|message input area]])\\\%0a%0aA skin definition can also load a %25blue%25.tabsrmm%25%25 theme definition file which contains font style and color definition for both the message history log and the input area. So it is possible, to load a complete skin by just loading a single file. Skins can be changed at runtime and it is possible to reload the currently selected skin which makes it easier for skin developers to preview their work. However, to load or reload a skin definition, all message windows must be closed.%0a%0aThe skin definition is plain text file and uses the .INI format. You can use any text editor you want to edit skins. The only valid file name extension is .tsk. %0a%0aImage path names are **RELATIVE** to the directory in which the skin file is located. The best way is to put all images and the skin definition file into a single directory.%0a%0aThe same applies to the theme file (.tabsrmm theme) - it has to be placed in the skin directory and the filename must be given without a path.%0a%0a==How to load a skin definition==%0a%0aRefer to [[UsingSkins|installing and loading skins]].%0a%0a===Related reading==%0a%0a* [[SkinningFormat|the skin definition format]] - for skin developers.%0a* [[ColorThemes|using color themes]] - alternative to skins, easier to customize with fewer possibilities%0a%0a----%0aCategory: [[!TabSRMM]]%0a
time=1288348780
title=Skins in TabSRMM 3
author:1288348780=admin
diff:1288348780:1288336110:=1d0%0a%3c (:title Skins in TabSRMM 3:)%0a4d2%0a%3c [[#teaser]]%0a13c11%0a%3c [[#teaserend]]%0a---%0a> %0a
host:1288348780=81.217.70.206
author:1288336110=admin
diff:1288336110:1288336033:=51,52d50%0a%3c * [[SkinningFormat|the skin definition format]] - for skin developers.%0a%3c * [[ColorThemes|using color themes]] - alternative to skins, easier to customize with fewer possibilities%0a
host:1288336110=81.217.70.206
author:1288336033=admin
diff:1288336033:1288335969:=48,51d47%0a%3c %0a%3c ===Related reading==%0a%3c %0a%3c %0a
host:1288336033=81.217.70.206
author:1288335969=admin
diff:1288335969:1288054721:=6,9c6,9%0a%3c * a skin definition file. This is an ordinary plain text file. The syntax is compatible with the well-known .INI - Format.\\\%0a%3c %0a%3c Typically, all files must be placed into a single directory. There are basically no restrictions where to put the files, but because the skinning engine is only using relative paths, the images must be at or below the folder in which the skin definition file is placed. The basic rule of **one skin per phyical directory** is important to understand. You cannot mix files from 2 different skin within the same directory.%0a%3c %0a---%0a> * a skin definition file. This is an ordinary plain text file. The syntax is compatible with the well-known .INI - Format.%0a> %0a> Typically, all files are placed into a single directory. There are basically no restrictions where to put the files, but because the skinning engine is only using relative pathnames, the images must be at or below the folder in which the skin definition file is placed.%0a> %0a18,19c18,19%0a%3c * Skin definition files have the extension '''.tsk''' and basically they define the rules how the various user interface elements should look like. A skin can optionally include a theme which will be imported when the skin is loaded. This allows users to create a complete customization pack, consisting of a skin and a matching theme.%0a%3c %0a---%0a> * Skin definition files have the extension '''.tsk''' and basically, they define the rules how the various user interface elements should look like. A skin can, optionally, reference a theme which will be imported when the skin is loaded. This allows users to create a complete customization pack, consisting of a skin and a matching theme.%0a> %0a22,23c22,23%0a%3c [[Plugins/IEView|IEView]] is a very popular addon for Miranda. When it is used and active for a message window, it will replace the default message log. Consequently, TabSRMM themes will not work when IEView is in use. Read the page about the [[History|message history]] for further information. Skins will however continue to work, because IEView only replaces the message log area but not the entire message window.%0a%3c %0a---%0a> [[Plugins/IEView|IEView]] is a very popular addon for Miranda. When it is used and active for a message window, it will replace the default message log. Consequently, tabSRMM themes will not work when IEView is in use. Read the page about the [[History|message history]] for further information. Skins will however continue to work, because IEView only replaces the message log area but not the entire message window.%0a> %0a30c30%0a%3c * the info panel background%0a---%0a> * the info panel fields%0a35,36c35,36%0a%3c * the surrounding regions of the 2 text areas ([[History|message history]] and [[InputArea|message input area]])\\\%0a%3c %0a---%0a> * the surrounding regions of the 2 text areas ([[TabSrmm:History|message history]] and [[TabSrmm:Inputarea|message input area]])%0a> %0a39,41c39,41%0a%3c The skin definition is plain text file and uses the .INI format. You can use any text editor you want to edit skins. The only valid file name extension is .tsk. %0a%3c %0a%3c Image path names are **RELATIVE** to the directory in which the skin file is located. The best way is to put all images and the skin definition file into a single directory.%0a---%0a> The skin definition is a simple .ini - style text file. You can use any text editor you want to edit them. The only valid filename extension is .tsk. You can download a sample skin definition at the end of this document.%0a> %0a> Image path names are *RELATIVE* to the directory in which the skin file is located. The best way is to put all images and the skin definition file into a single directory.%0a
host:1288335969=81.217.70.206
author:1288054721=admin
diff:1288054721:1288054574:=47c47,51%0a%3c Refer to [[UsingSkins|installing and loading skins]].%0a---%0a> Go to %25class=option%25Customize->Message Window Skin%25%25 to select a skin file using a simple file selection dialog. You must hit the *Apply skin now" button to actually load it and can unload it with the *Unload skin* button. The checkbox controls whether tabsrmm will load the skin on startup or not.%0a> %0a> The options in the lower part allow you to select which parts should be loaded by the skin. If you don't want to loose your current message log theme or your templates, uncheck them accordingly.%0a> %0a> Note that you need to close all message containers before loading a skin - otherwise you will get a warning and the containers will close automatically. When you modify the skin definition while Miranda is running, you can simply press the %25blue%25*Reload*%25%25 button to refresh the skin. Again, all message containers need to be closed when doing so. You can also uncheck the checkbox to unload the skin.%0a
host:1288054721=81.217.70.206
author:1288054574=admin
diff:1288054574:1288054457:=51a52,410%0a> %0a> %0a> ==The FORMAT==%0a> %0a> ===A skin definition contains the following elements===%0a> %0a> (:include Template/Formatting#note#endnote Text="Note: A skin does not need to be '''complete'''. TabSRMM supports partially skinning, so you can define a skin which only changes the look of a few elements (buttons for example). %0a> %0a> * skin elements%0a> * assigned image items%0a> * independent image items%0a> * button definitions%0a> %0a> '''Skin elements''' specify the skinnable parts of the message window. These elements MUST start with a %25 character and the name must be one of the recognized element names. Currently, tabsrmm knows the following element types (names ARE case sensitive):%0a> %0a> The order in which they appear in the skin file doesn't matter. Each skin element is a single section in the .TSK file.%0a> %0a> * Container%0a> * Button%0a> * Buttonpressed%0a> * Buttonmouseover%0a> * InfoPanelBackground%0a> * Titlebutton%0a> * Titlebuttonpressed%0a> * Titlebuttonmouseover%0a> * Tabpage%0a> * Tabitem%0a> * Tabitem_hottrack%0a> * Tabitem_bottom%0a> * Tabitem_hottrack_bottom%0a> * Tabitem_active%0a> * Tabitem_active_bottom%0a> * Frame%0a> * FrameInactive%0a> * InputArea%0a> * MessageLog%0a> * Statusbarpanel%0a> * Statusbar%0a> * Userlist%0a> %0a> Items which are not configured in the skin definition file are ignored by the skinning engine (that is, these items are then rendered unskinned and will look like in any other tabSRMM window which does not use a skin).%0a> %0a> Item records contain information about the item itself. It offers similar options like the skinning sytem in clist_nicer+ There are default values for each of these parameters; most of them are using system defaults (like default background color and such).%0a> %0a> |COLOR1|First color|%0a> |COLOR2|2nd color|%0a> |TEXTCOLOR|color for the text - note only useful for a few items like buttons. The text color for Tab items can be set in tabSRMM directly with more flexibility.|%0a> |TOP/LEFT/RIGHT/BOTTOM|the item margins (in pixels)|%0a> |ALPHA|The transparency value (alpha). Values go from 0 (completely transparent) to 100 (completely opaque - values are therefore in PERCENT).|%0a> |GRADIENT|Set this to one of "up", "down", "right", "left" (without the quotes) to specify the gradient direction.%0a> Default is no gradient.|%0a> |CORNER|A string which may contain the values "tl", "tr", "bl", "br" (again, w/o quotes). Separate multiple entries by commas. tl = top left, tr = top right, bl = bottom left, br = bottom right. Example: Corner=tl,tr  (will result in rounded corners for the top left and top right corner).|%0a> |COLOR2_TRANSPARENT|Set it to 1 if you want to have the 2nd color transparent, so that the gradient will blend with the background.|%0a> |RADIUS|A numeric value specifying the corner radius when rounded corners are used.|%0a> %0a> It is possible to skin only some items and leave the others unskinned. If a skin is loaded, items which are left out by the skin definition will be rendered in a standard way, so they will look like ordinary windows screen elements.%0a> %0a> For more, see the examples below.%0a>                       %0a> [@%0a> The following item defines the container background. All %0a> parts of the message window which are not covered by other%0a> elements will appear with that skin.%0a> %0a> This element defines a gradient running from left to right,%0a> beginning with the first (brighter color) #f5f5f5.%0a> %0a> [%25Container]%0a> ALPHA=100%0a> COLOR1=f5f5f5%0a> COLOR2=e5e5e5%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=0%0a> GRADIENT=right%0a> RADIUS=0%0a> %0a> This is a special Item. %25Default is read automatically %0a> and its values are used as defaults when reading the%0a> other skin items later. With %25Default, you can set %0a> fallback values.%0a> %0a> [%25Default]%0a> ALPHA=100%0a> COLOR1=ffffff%0a> COLOR2=ffffff%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=None%0a> GRADIENT=None%0a> BOTTOM=2%0a> LEFT=2%0a> RIGHT=2%0a> TOP=2%0a> BRDERSTYLE=0%0a> %0a> [%25Tabpage]%0a> ALPHA=30%0a> COLOR1=aadaed%0a> COLOR2=aadaed%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=None%0a> GRADIENT=None%0a> BRDERSTYLE=0%0a> %0a> [%25Tabitem_active_bottom]%0a> ALPHA=100%0a> COLOR1=cccccc%0a> COLOR2=a0a0a0%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=none%0a> GRADIENT=up%0a> radius=12%0a> %0a> [%25Tabitem_active]%0a> ALPHA=100%0a> COLOR1=f0f0f0%0a> COLOR2=e0e0e0%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=tl,tr%0a> GRADIENT=down%0a> radius=6%0a> %0a> [%25Tabitem]%0a> ALPHA=100%0a> COLOR1=f0f0f0%0a> COLOR2=e0e0e0%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=tl,tr%0a> GRADIENT=up%0a> radius=6%0a> %0a> [%25Buttonnotpressed]%0a> ALPHA=100%0a> COLOR1=bbbbbb%0a> COLOR2=dddddd%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=none%0a> GRADIENT=down%0a> RADIUS=6%0a> %0a> [%25Buttonmouseover]%0a> ALPHA=100%0a> COLOR1=888888%0a> COLOR2=888888%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=tl,tr,br,bl%0a> GRADIENT=none%0a> RADIUS=6%0a> %0a> [%25InfoPanelfield]%0a> ALPHA=100%0a> COLOR1=e0e0e0%0a> COLOR2=ffffff%0a> COLOR2_TRANSPARENT=0%0a> TEXTCOLOR=202020%0a> CORNER=tl,tr,br,bl%0a> GRADIENT=left%0a> RADIUS=8%0a> top=1%0a> bottom=1%0a> @]%0a> %0a> ==2. Image items==%0a> %0a> Image items are separated from the normal skin elements definitions. This allows to re-use a single image for multiple skin elements. Images are optional, because the skinning engine can work without them and draw skin items in a traditional way, using gradients only.%0a> %0a> Images *HAVE* to be 32bit PNG images - other formats are not supported. They can be partially transparent using per-pixel alpha values. %0a> %0a> ===There are 2 types of image items available:===%0a> %0a> * Assigned image items - these are directly linked to at least one of the skin elements. The name of an assigned image item must start with the *$* character.%0a> %0a> * Independent image items - these are not linked and their main purpose is to provide the look for custom buttons. The name of an independent image item must start with the *@* character.%0a> %0a> ===Specifiying the image source for an image item===%0a> %0a> There are 2 ways to do this:%0a> %0a> * With the *Image=xxx.png* statement, you can specify the source file.%0a> %0a> * With the *Glyph=x,y,x1,y1* statement, you specify the rectangle in the *GLPYH* image. The glpyhs image is a special item. Its name must be *$glyphs* and it must exist when you use reference the glyph image in any other image item. It's not mandatory though - if you don't want to use it, you can load each image item from an independent .PNG image using the *Image=* statement. The advantage of using glyphs is that it will provide faster rendering and consume *MUCH* less resources. The glpyh way allows that all skin textures can exist within a single image file.%0a> %0a> ===Sizing margins:===%0a>  %0a> Sizing margins have to be specified as %25blue%25Left, Right, Top and Bottom.%25%25 These margins divide the image into 9 parts. The corner parts are rendered without stretching or shrinking, other parts of the image are stretched to make it fit the target area. Sizing margins are only valid and used when ALL 4 margin values are specified.%0a>  %0a> %25blueALPHA%25%25 is a constant alpha value which is applied AFTER per pixel alpha values- this can be used to make a non-transparent image translucent. Alpha values are in percent, so the valid range is from 0 (completely transparent) to 100 (completely opaque).%0a> %0a> %25{color:blue}PERPIXEL%25 is a boolean value (0 or 1). If it is 1 (or any other value different from zero), the image will be rendered with perpixel alpha values.%0a> %0a> +assign images to actual skin item(s). (assigned image items only)+%0a> %0a> This is done with the %25{color:blue}ItemX=Itemname%25 statement. X is a 0-based index number, so the first assignment has to be Item0=foo, the 2nd Item1=bar and so on. Itemname refers to one of the skin item names listed at the beginning of this document, WITHOUT the %25 character. %0a> %0a> %25{color:red}ColorKey%25%0a> this is a special color value which will be used to make areas of the containe transparent (e.g. it can be used for rounded corners). The color key can be any value you want, but remember that any pixel with this color will appear completely transparent. the color key DOES ONLY MAKE SENSE for the container skin item and is ignored elsewhere.%0a> %0a> %25{color:blue}FillColor%25 This is a color value, which, if present, will be used to fill the inner part of the target area. You can use this if you only "need" the margin areas of the image (one example would be the Tabpage which is usually invisible covered by the message log and other message window elements). The advantage is that by using a fill color, rendering will be faster. Only makes sense for a "divided" image item (all 4 sizing margins present).%0a> %0a> Let's look at a few examples for image items:%0a> %0a> %3cpre>%0a> ; Defining the global glyph image%0a> %0a> [$glyphs]%0a> Image=glyphs.png%0a> Alpha=100%0a> Perpixel=1%0a> %0a> [$Tabitem]%0a> Image=select.png%0a> Right=2%0a> Top=2%0a> Bottom=2%0a> Left=2%0a> Alpha=80%0a> Item0=Tabitem_bottom%0a> Item1=Tabitem_active_bottom%0a> %0a> [$Button]%0a> Image=button.png%0a> Right=3%0a> Top=3%0a> Bottom=3%0a> Left=3%0a> Alpha=100%0a> Item0=Buttonnotpressed%0a> Perpixel=1%0a> %0a> [$Buttonhover]%0a> %0a>   ;reference the rectangle in the glpyh image %0a>   ;(top/left, bottom/right corner)%0a> %0a> Glyph=10,10,32,32%0a> Right=2%0a> Top=2%0a> Bottom=1%0a> Left=2%0a> Alpha=100%0a> Item0=Buttonmouseover%0a> Perpixel=1%0a> %3c/pre>%0a> %0a> The global section has some general settings for the skin. %25{color:red}The 3 glyphs are used for the min/max/close button on the title bar.%25%0a> %0a> SbarHeight = height of the status bar in pixels. Using this, you can override the systems default status bar height and make your status bar "match" the background skin image for the container window.%0a> %0a> FontColor is the color for text output in the message window which is normally printed with the system text color (black).%0a> this affects: the info panel labels, the status bar text, text on buttons and elsewhere.%0a> %0a> |Version=1|mandatory, don't remove or change, or the skin won't load.|%0a> |Signature=101|same - don't remove or change.|%0a> |FrameLessMode|If set to a value not equal to zero, containers will enter frameless mode. That means, they do not use Windows theme to skin the border and caption bar. Using this mode, you can define your own border and caption bar look by configuring the skin items %25{color:blue}$Frame%25 and %25{color:blue}$FrameInactive%25. They are defined in the same way as other skin items. See the next page for more info on skinning the window frame.|%0a> %0a> |LightShadow / DarkShadow|simple color definitions to draw "beveled" 3d shadow effects in some cases. They should match your overall skin color theme.|%0a> |TabTextNormal/Active/Unread/Hottrack|Defines with which colors tab labels are drawn depending on the state of the tab.|%0a> %0a> %3cpre>%0a> [Global]%0a> CloseGlyph=close.ico%0a> MinimizeGlyph=minimize.ico%0a> MaximizeGlyph=maximize.ico%0a> ;SbarHeight=22%0a> FontColor=000000%0a> Version=1%0a> Signature=101%0a> FrameLessMode=0%0a> %0a> LightShadow=F4F4F1%0a> DarkShadow=B0ACA0%0a> TabTextNormal=CCCC00%0a> TabTextActive=0000BB%0a> TabTextUnread=BB0000%0a> TabTextHottrack=00bb00%0a> %3c/pre>%0a> %0a> The client area section defines the inner padding of the message container. The values left, top, bottom and right are padding values added to the container itself and the Inner value is a padding value added to the tab control. Setting it to 0 will make the tab control border invisible, setting one or all of the left,top,bottom,right values to 0 will make the borders as small as possible.%0a> %0a> %3cpre>%0a> [ClientArea]%0a> Left=2%0a> Right=2%0a> Top=2%0a> Bottom=0%0a> Inner=1%0a> %3c/pre>%0a> %0a> The WindowFrame section is only valid in FrameLessMode (that is, when you are using your own border and caption bar skinning). It defines the width of the Window border(s) - one value per side and one for the caption bar itself.%0a> %0a> The other values in this section define the metrics for the title bar buttons - width, height and a top offset and the +CaptionOffset+ defines the top offset for the window icon and the title bar text.%0a> %0a> %3cpre>%0a> [WindowFrame]%0a> Left=4%0a> Right=4%0a> Bottom=4%0a> Caption=22%0a> ClipFrame=1%0a> RadiusTL=6%0a> TitleButtonWidth = 12%0a> TitleButtonHeight = 12%0a> TitleButtonTopOffset = 7%0a> CaptionOffset = 6%0a> %3c/pre>%0a> The next page will answer some common questions, so if things don't work as they should, just read on...%0a> %0a> %3c!--nextpage-->%0a> %0a> h3. Skinning the window frame%0a> %0a> This is a somewhat special case. To skin the window frame, you have to define the following 2 items:%0a> %0a> * Frame%0a> * FrameInactive%0a> %0a> Of course, you can add image items to these skin definitions like everywhere else. %0a> %0a> To enable the skinned frame, you need to add:%0a> %0a> FramelessMode=1%0a> %0a> to the *[Global]* section. Note that, *both* items (Frame and FrameInactive) *must* be properly defined, because the message window will always use both, depending on the active state of the window. When %25{color:blue}FramelessMode%25 is undefined or set to 0, the frame will appear with the operating systems theme.%0a> %0a> When using frame skin defintions, you also *HAVE* to define the title buttons, that is, you have to valid skin definitions for the 3 items starting with %25{color:blue}Titlebutton%25. %0a> %0a> When using image items for the frame, you really *SHOULD* use the %25{color:blue}FillColor%25 statement to speed up drawing of the inner part which will *always* be invisible anyway, because the frame is only a few pixels wide. Adjust the sizing margins of the image items in a way that it will properly stretch on the frame, and then setup the window frame metrics:%0a> %0a> %3cpre>%0a> [WindowFrame]%0a> Left=4%0a> Right=4%0a> Bottom=4%0a> Caption=20%0a> ClipFrame=1%0a> RadiusTL=6%0a> %3c/pre>%0a> %0a> %25{color:blue}Left, Right, Bottom and Caption%25 are the widths (in pixels) for the respective border elemets (Caption = title bar height).%0a> %0a> %0a> h3. Some important things you should know%0a> %0a> # _Tabs are not accepting the skins, they are still rendered with visual styles, what's wrong?_%0a> %25{color:green}You need to disable visual styles on the tab control. To do so, open a container, right click the button bar OR an active tab and choose%25 %25{color:blue}Configure Tab Appearance...%25. %25{color:green}On the following dialog box, you can disable visual styles%25.%0a> %0a> # _Will it ever be a fully layered skinning engine, compareable to clist_modern?_%0a> %25{color:green}Very unlikely. The message windows internals are very different from the contact list. While the contact list draws everything itself, the message window is using standard windows controls to do huge parts of the job. The entire message history is rendered with a rich edit text editor control for example. This wouldn't work very well in a layered environment.%25%0a> %25{color:green}Also, IEView would probably never work within a layered message window.%25%0a> %3cbr />%0a> %0a> "Download sample skin":http://miranda.or.at/wp-content/uploads/2006/03/skin.zip%0a
host:1288054574=81.217.70.206
author:1288054457=admin
diff:1288054457:1288050237:=1c1%0a%3c %3c|[[TabSRMM.#skinning|Skinning Index]]|>%0a---%0a> %3c|[[TabSRMM.#skinning#endskinning|Skinning Index]]|>%0a
host:1288054457=81.217.70.206
author:1288050237=admin
diff:1288050237:1287786879:=411,412c411,412%0a%3c ----%0a%3c Category: [[!TabSRMM]]%0a---%0a> %0a> [[Category:tabSRMM]]%0a
host:1288050237=81.217.70.206
author:1287786879=admin
diff:1287786879:1287786777:=11a12,15%0a> ==Supported configurations==%0a> %0a> Skins are supported on Windows 2000 or later, the skin engine does not work under Windows 98/ME or NT4 and is therefore disabled when running tabSRMM under one of these operating systems.%0a> %0a37,38c41,44%0a%3c A skin definition can also load a %25blue%25.tabsrmm%25%25 theme definition file which contains font style and color definition for both the message history log and the input area. So it is possible, to load a complete skin by just loading a single file. Skins can be changed at runtime and it is possible to reload the currently selected skin which makes it easier for skin developers to preview their work. However, to load or reload a skin definition, all message windows must be closed.%0a%3c %0a---%0a> A skin definition can also load a %25blue}%25.tabsrmm%25%25 theme definition file which contains font style and color definition for both the message history log and the input area. So it is possible, to load a complete skin by just loading a single file. Skins can be changed at runtime and it is possible to reload the currently selected skin which makes it easier for skin developers to preview their work. However, to load or reload a skin definition, all message windows must be closed.%0a> %0a> These features are available in tabSRMM 0.9.9.200 and later. For best results, you should obtain a recent copy of tabSRMM by downloading a miranda nightly.%0a> %0a51,53c57,59%0a%3c Note that you need to close all message containers before loading a skin - otherwise you will get a warning and the containers will close automatically. When you modify the skin definition while Miranda is running, you can simply press the %25blue%25*Reload*%25%25 button to refresh the skin. Again, all message containers need to be closed when doing so. You can also uncheck the checkbox to unload the skin.%0a%3c %0a%3c %0a---%0a> Note that you need to close all message containers before loading a skin - otherwise you will get a warning and the containers will close automatically. When you modify the skin definition while Miranda is running, you can simply press the %25{color:blue}*Reload*%25 button to refresh the skin. Again, all message containers need to be closed when doing so. You can also uncheck the checkbox to unload the skin.%0a> %0a> %0a58c64%0a%3c (:include Template/Formatting#note#endnote Text="Note: A skin does not need to be '''complete'''. TabSRMM supports partially skinning, so you can define a skin which only changes the look of a few elements (buttons for example). %0a---%0a> (:include Template/Formatting#note#endnote Text="Note: A skin does not need to be "complete". TabSRMM supports partially skinning, so you can define a skin which only changes the look of a few elements (buttons for example). It is also ok to use the skin file only for defining custom buttons (see below for more info on this topic).:)%0a
host:1287786879=81.217.70.206
author:1287786777=admin
diff:1287786777:1287786722:=22a23,27%0a> %0a> {{Ok|To '''export''' the current message log settings to a .tabsrmm theme file, do the following:%0a> * open a message window%0a> * Use {{Menu|Message Log->Export Message Log Settings...}} from the menu bar. If the menu bar is not visible, hit {{Key|Ctrl-T}} to show it.%0a> * A "Save As" file dialog will open. Select a file name and hit the ok button.|1em|0}}%0a
host:1287786777=81.217.70.206
author:1287786722=admin
diff:1287786722:1287786722:=1,423d0%0a%3c %3c|[[TabSRMM.#skinning#endskinning|Skinning Index]]|>%0a%3c =Skinning tabSRMM - how it works=%0a%3c Beginning with version 1.0, tabSRMM introduced a simple skinning engine. This allows the user to customize the look of the entire message window by using a skin. Usually, a skin consists of the following elements:%0a%3c %0a%3c * images (supported are PNG images in 32bit RGBA format only, this allows full per-pixel alphablending)%0a%3c * a skin definition file. This is an ordinary plain text file. The syntax is compatible with the well-known .INI - Format.%0a%3c %0a%3c Typically, all files are placed into a single directory. There are basically no restrictions where to put the files, but because the skinning engine is only using relative pathnames, the images must be at or below the folder in which the skin definition file is placed.%0a%3c %0a%3c Advanced skinning techniques allow to use only a single image file. Skin elements are then created by "extracting" rectangular areas from that image file.%0a%3c %0a%3c ==Supported configurations==%0a%3c %0a%3c Skins are supported on Windows 2000 or later, the skin engine does not work under Windows 98/ME or NT4 and is therefore disabled when running tabSRMM under one of these operating systems.%0a%3c %0a%3c ==Themes vs. skins==%0a%3c %0a%3c One thing a user should understand is the difference between a [[Theme|theme]] and a skin. A theme is a set of font-, template- and color definitions which determine the look and layout of the text areas inside the message window. A theme does %25red%25not%25%25 alter the look of other message window elements, like title bar, buttons or the status bar.%0a%3c %0a%3c * Themes are files with the extension '''.tabsrmm'''. They can be manually written, but the preferred method is to use the %25green%25'''export message log settings'''%25%25 feature of tabSRMM. This will collect and export all settings which compose a theme and save them to a '''.tabsrmm''' file. Such a file can later be imported again.%0a%3c %0a%3c * Skin definition files have the extension '''.tsk''' and basically, they define the rules how the various user interface elements should look like. A skin can, optionally, reference a theme which will be imported when the skin is loaded. This allows users to create a complete customization pack, consisting of a skin and a matching theme.%0a%3c %0a%3c {{Ok|To '''export''' the current message log settings to a .tabsrmm theme file, do the following:%0a%3c * open a message window%0a%3c * Use {{Menu|Message Log->Export Message Log Settings...}} from the menu bar. If the menu bar is not visible, hit {{Key|Ctrl-T}} to show it.%0a%3c * A "Save As" file dialog will open. Select a file name and hit the ok button.|1em|0}}%0a%3c %0a%3c == Skins, themes and how they work with other plugins like IEView ==%0a%3c %0a%3c [[Plugins/IEView|IEView]] is a very popular addon for Miranda. When it is used and active for a message window, it will replace the default message log. Consequently, tabSRMM themes will not work when IEView is in use. Read the page about the [[History|message history]] for further information. Skins will however continue to work, because IEView only replaces the message log area but not the entire message window.%0a%3c %0a%3c Similarly, when using [[Plugins/HistoryPP|History++]] to display the message history, the same applies.%0a%3c %0a%3c ==Which elements are skinable?==%0a%3c %0a%3c * tabs (and the tab page itself)%0a%3c * the container background%0a%3c * the info panel fields%0a%3c * the window frame and title bar%0a%3c * the title buttons%0a%3c * the status bar background%0a%3c * the status bar panels (the content rectangles which hold the text or icons)%0a%3c * the surrounding regions of the 2 text areas ([[TabSrmm:History|message history]] and [[TabSrmm:Inputarea|message input area]])%0a%3c %0a%3c A skin definition can also load a %25blue}%25.tabsrmm%25%25 theme definition file which contains font style and color definition for both the message history log and the input area. So it is possible, to load a complete skin by just loading a single file. Skins can be changed at runtime and it is possible to reload the currently selected skin which makes it easier for skin developers to preview their work. However, to load or reload a skin definition, all message windows must be closed.%0a%3c %0a%3c These features are available in tabSRMM 0.9.9.200 and later. For best results, you should obtain a recent copy of tabSRMM by downloading a miranda nightly.%0a%3c %0a%3c The skin definition is a simple .ini - style text file. You can use any text editor you want to edit them. The only valid filename extension is .tsk. You can download a sample skin definition at the end of this document.%0a%3c %0a%3c Image path names are *RELATIVE* to the directory in which the skin file is located. The best way is to put all images and the skin definition file into a single directory.%0a%3c %0a%3c The same applies to the theme file (.tabsrmm theme) - it has to be placed in the skin directory and the filename must be given without a path.%0a%3c %0a%3c ==How to load a skin definition==%0a%3c %0a%3c Go to %25class=option%25Customize->Message Window Skin%25%25 to select a skin file using a simple file selection dialog. You must hit the *Apply skin now" button to actually load it and can unload it with the *Unload skin* button. The checkbox controls whether tabsrmm will load the skin on startup or not.%0a%3c %0a%3c The options in the lower part allow you to select which parts should be loaded by the skin. If you don't want to loose your current message log theme or your templates, uncheck them accordingly.%0a%3c %0a%3c Note that you need to close all message containers before loading a skin - otherwise you will get a warning and the containers will close automatically. When you modify the skin definition while Miranda is running, you can simply press the %25{color:blue}*Reload*%25 button to refresh the skin. Again, all message containers need to be closed when doing so. You can also uncheck the checkbox to unload the skin.%0a%3c %0a%3c %0a%3c ==The FORMAT==%0a%3c %0a%3c ===A skin definition contains the following elements===%0a%3c %0a%3c (:include Template/Formatting#note#endnote Text="Note: A skin does not need to be "complete". TabSRMM supports partially skinning, so you can define a skin which only changes the look of a few elements (buttons for example). It is also ok to use the skin file only for defining custom buttons (see below for more info on this topic).:)%0a%3c %0a%3c * skin elements%0a%3c * assigned image items%0a%3c * independent image items%0a%3c * button definitions%0a%3c %0a%3c '''Skin elements''' specify the skinnable parts of the message window. These elements MUST start with a %25 character and the name must be one of the recognized element names. Currently, tabsrmm knows the following element types (names ARE case sensitive):%0a%3c %0a%3c The order in which they appear in the skin file doesn't matter. Each skin element is a single section in the .TSK file.%0a%3c %0a%3c * Container%0a%3c * Button%0a%3c * Buttonpressed%0a%3c * Buttonmouseover%0a%3c * InfoPanelBackground%0a%3c * Titlebutton%0a%3c * Titlebuttonpressed%0a%3c * Titlebuttonmouseover%0a%3c * Tabpage%0a%3c * Tabitem%0a%3c * Tabitem_hottrack%0a%3c * Tabitem_bottom%0a%3c * Tabitem_hottrack_bottom%0a%3c * Tabitem_active%0a%3c * Tabitem_active_bottom%0a%3c * Frame%0a%3c * FrameInactive%0a%3c * InputArea%0a%3c * MessageLog%0a%3c * Statusbarpanel%0a%3c * Statusbar%0a%3c * Userlist%0a%3c %0a%3c Items which are not configured in the skin definition file are ignored by the skinning engine (that is, these items are then rendered unskinned and will look like in any other tabSRMM window which does not use a skin).%0a%3c %0a%3c Item records contain information about the item itself. It offers similar options like the skinning sytem in clist_nicer+ There are default values for each of these parameters; most of them are using system defaults (like default background color and such).%0a%3c %0a%3c |COLOR1|First color|%0a%3c |COLOR2|2nd color|%0a%3c |TEXTCOLOR|color for the text - note only useful for a few items like buttons. The text color for Tab items can be set in tabSRMM directly with more flexibility.|%0a%3c |TOP/LEFT/RIGHT/BOTTOM|the item margins (in pixels)|%0a%3c |ALPHA|The transparency value (alpha). Values go from 0 (completely transparent) to 100 (completely opaque - values are therefore in PERCENT).|%0a%3c |GRADIENT|Set this to one of "up", "down", "right", "left" (without the quotes) to specify the gradient direction.%0a%3c Default is no gradient.|%0a%3c |CORNER|A string which may contain the values "tl", "tr", "bl", "br" (again, w/o quotes). Separate multiple entries by commas. tl = top left, tr = top right, bl = bottom left, br = bottom right. Example: Corner=tl,tr  (will result in rounded corners for the top left and top right corner).|%0a%3c |COLOR2_TRANSPARENT|Set it to 1 if you want to have the 2nd color transparent, so that the gradient will blend with the background.|%0a%3c |RADIUS|A numeric value specifying the corner radius when rounded corners are used.|%0a%3c %0a%3c It is possible to skin only some items and leave the others unskinned. If a skin is loaded, items which are left out by the skin definition will be rendered in a standard way, so they will look like ordinary windows screen elements.%0a%3c %0a%3c For more, see the examples below.%0a%3c                       %0a%3c [@%0a%3c The following item defines the container background. All %0a%3c parts of the message window which are not covered by other%0a%3c elements will appear with that skin.%0a%3c %0a%3c This element defines a gradient running from left to right,%0a%3c beginning with the first (brighter color) #f5f5f5.%0a%3c %0a%3c [%25Container]%0a%3c ALPHA=100%0a%3c COLOR1=f5f5f5%0a%3c COLOR2=e5e5e5%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=0%0a%3c GRADIENT=right%0a%3c RADIUS=0%0a%3c %0a%3c This is a special Item. %25Default is read automatically %0a%3c and its values are used as defaults when reading the%0a%3c other skin items later. With %25Default, you can set %0a%3c fallback values.%0a%3c %0a%3c [%25Default]%0a%3c ALPHA=100%0a%3c COLOR1=ffffff%0a%3c COLOR2=ffffff%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=None%0a%3c GRADIENT=None%0a%3c BOTTOM=2%0a%3c LEFT=2%0a%3c RIGHT=2%0a%3c TOP=2%0a%3c BRDERSTYLE=0%0a%3c %0a%3c [%25Tabpage]%0a%3c ALPHA=30%0a%3c COLOR1=aadaed%0a%3c COLOR2=aadaed%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=None%0a%3c GRADIENT=None%0a%3c BRDERSTYLE=0%0a%3c %0a%3c [%25Tabitem_active_bottom]%0a%3c ALPHA=100%0a%3c COLOR1=cccccc%0a%3c COLOR2=a0a0a0%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=none%0a%3c GRADIENT=up%0a%3c radius=12%0a%3c %0a%3c [%25Tabitem_active]%0a%3c ALPHA=100%0a%3c COLOR1=f0f0f0%0a%3c COLOR2=e0e0e0%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=tl,tr%0a%3c GRADIENT=down%0a%3c radius=6%0a%3c %0a%3c [%25Tabitem]%0a%3c ALPHA=100%0a%3c COLOR1=f0f0f0%0a%3c COLOR2=e0e0e0%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=tl,tr%0a%3c GRADIENT=up%0a%3c radius=6%0a%3c %0a%3c [%25Buttonnotpressed]%0a%3c ALPHA=100%0a%3c COLOR1=bbbbbb%0a%3c COLOR2=dddddd%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=none%0a%3c GRADIENT=down%0a%3c RADIUS=6%0a%3c %0a%3c [%25Buttonmouseover]%0a%3c ALPHA=100%0a%3c COLOR1=888888%0a%3c COLOR2=888888%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=tl,tr,br,bl%0a%3c GRADIENT=none%0a%3c RADIUS=6%0a%3c %0a%3c [%25InfoPanelfield]%0a%3c ALPHA=100%0a%3c COLOR1=e0e0e0%0a%3c COLOR2=ffffff%0a%3c COLOR2_TRANSPARENT=0%0a%3c TEXTCOLOR=202020%0a%3c CORNER=tl,tr,br,bl%0a%3c GRADIENT=left%0a%3c RADIUS=8%0a%3c top=1%0a%3c bottom=1%0a%3c @]%0a%3c %0a%3c ==2. Image items==%0a%3c %0a%3c Image items are separated from the normal skin elements definitions. This allows to re-use a single image for multiple skin elements. Images are optional, because the skinning engine can work without them and draw skin items in a traditional way, using gradients only.%0a%3c %0a%3c Images *HAVE* to be 32bit PNG images - other formats are not supported. They can be partially transparent using per-pixel alpha values. %0a%3c %0a%3c ===There are 2 types of image items available:===%0a%3c %0a%3c * Assigned image items - these are directly linked to at least one of the skin elements. The name of an assigned image item must start with the *$* character.%0a%3c %0a%3c * Independent image items - these are not linked and their main purpose is to provide the look for custom buttons. The name of an independent image item must start with the *@* character.%0a%3c %0a%3c ===Specifiying the image source for an image item===%0a%3c %0a%3c There are 2 ways to do this:%0a%3c %0a%3c * With the *Image=xxx.png* statement, you can specify the source file.%0a%3c %0a%3c * With the *Glyph=x,y,x1,y1* statement, you specify the rectangle in the *GLPYH* image. The glpyhs image is a special item. Its name must be *$glyphs* and it must exist when you use reference the glyph image in any other image item. It's not mandatory though - if you don't want to use it, you can load each image item from an independent .PNG image using the *Image=* statement. The advantage of using glyphs is that it will provide faster rendering and consume *MUCH* less resources. The glpyh way allows that all skin textures can exist within a single image file.%0a%3c %0a%3c ===Sizing margins:===%0a%3c  %0a%3c Sizing margins have to be specified as %25blue%25Left, Right, Top and Bottom.%25%25 These margins divide the image into 9 parts. The corner parts are rendered without stretching or shrinking, other parts of the image are stretched to make it fit the target area. Sizing margins are only valid and used when ALL 4 margin values are specified.%0a%3c  %0a%3c %25blueALPHA%25%25 is a constant alpha value which is applied AFTER per pixel alpha values- this can be used to make a non-transparent image translucent. Alpha values are in percent, so the valid range is from 0 (completely transparent) to 100 (completely opaque).%0a%3c %0a%3c %25{color:blue}PERPIXEL%25 is a boolean value (0 or 1). If it is 1 (or any other value different from zero), the image will be rendered with perpixel alpha values.%0a%3c %0a%3c +assign images to actual skin item(s). (assigned image items only)+%0a%3c %0a%3c This is done with the %25{color:blue}ItemX=Itemname%25 statement. X is a 0-based index number, so the first assignment has to be Item0=foo, the 2nd Item1=bar and so on. Itemname refers to one of the skin item names listed at the beginning of this document, WITHOUT the %25 character. %0a%3c %0a%3c %25{color:red}ColorKey%25%0a%3c this is a special color value which will be used to make areas of the containe transparent (e.g. it can be used for rounded corners). The color key can be any value you want, but remember that any pixel with this color will appear completely transparent. the color key DOES ONLY MAKE SENSE for the container skin item and is ignored elsewhere.%0a%3c %0a%3c %25{color:blue}FillColor%25 This is a color value, which, if present, will be used to fill the inner part of the target area. You can use this if you only "need" the margin areas of the image (one example would be the Tabpage which is usually invisible covered by the message log and other message window elements). The advantage is that by using a fill color, rendering will be faster. Only makes sense for a "divided" image item (all 4 sizing margins present).%0a%3c %0a%3c Let's look at a few examples for image items:%0a%3c %0a%3c %3cpre>%0a%3c ; Defining the global glyph image%0a%3c %0a%3c [$glyphs]%0a%3c Image=glyphs.png%0a%3c Alpha=100%0a%3c Perpixel=1%0a%3c %0a%3c [$Tabitem]%0a%3c Image=select.png%0a%3c Right=2%0a%3c Top=2%0a%3c Bottom=2%0a%3c Left=2%0a%3c Alpha=80%0a%3c Item0=Tabitem_bottom%0a%3c Item1=Tabitem_active_bottom%0a%3c %0a%3c [$Button]%0a%3c Image=button.png%0a%3c Right=3%0a%3c Top=3%0a%3c Bottom=3%0a%3c Left=3%0a%3c Alpha=100%0a%3c Item0=Buttonnotpressed%0a%3c Perpixel=1%0a%3c %0a%3c [$Buttonhover]%0a%3c %0a%3c   ;reference the rectangle in the glpyh image %0a%3c   ;(top/left, bottom/right corner)%0a%3c %0a%3c Glyph=10,10,32,32%0a%3c Right=2%0a%3c Top=2%0a%3c Bottom=1%0a%3c Left=2%0a%3c Alpha=100%0a%3c Item0=Buttonmouseover%0a%3c Perpixel=1%0a%3c %3c/pre>%0a%3c %0a%3c The global section has some general settings for the skin. %25{color:red}The 3 glyphs are used for the min/max/close button on the title bar.%25%0a%3c %0a%3c SbarHeight = height of the status bar in pixels. Using this, you can override the systems default status bar height and make your status bar "match" the background skin image for the container window.%0a%3c %0a%3c FontColor is the color for text output in the message window which is normally printed with the system text color (black).%0a%3c this affects: the info panel labels, the status bar text, text on buttons and elsewhere.%0a%3c %0a%3c |Version=1|mandatory, don't remove or change, or the skin won't load.|%0a%3c |Signature=101|same - don't remove or change.|%0a%3c |FrameLessMode|If set to a value not equal to zero, containers will enter frameless mode. That means, they do not use Windows theme to skin the border and caption bar. Using this mode, you can define your own border and caption bar look by configuring the skin items %25{color:blue}$Frame%25 and %25{color:blue}$FrameInactive%25. They are defined in the same way as other skin items. See the next page for more info on skinning the window frame.|%0a%3c %0a%3c |LightShadow / DarkShadow|simple color definitions to draw "beveled" 3d shadow effects in some cases. They should match your overall skin color theme.|%0a%3c |TabTextNormal/Active/Unread/Hottrack|Defines with which colors tab labels are drawn depending on the state of the tab.|%0a%3c %0a%3c %3cpre>%0a%3c [Global]%0a%3c CloseGlyph=close.ico%0a%3c MinimizeGlyph=minimize.ico%0a%3c MaximizeGlyph=maximize.ico%0a%3c ;SbarHeight=22%0a%3c FontColor=000000%0a%3c Version=1%0a%3c Signature=101%0a%3c FrameLessMode=0%0a%3c %0a%3c LightShadow=F4F4F1%0a%3c DarkShadow=B0ACA0%0a%3c TabTextNormal=CCCC00%0a%3c TabTextActive=0000BB%0a%3c TabTextUnread=BB0000%0a%3c TabTextHottrack=00bb00%0a%3c %3c/pre>%0a%3c %0a%3c The client area section defines the inner padding of the message container. The values left, top, bottom and right are padding values added to the container itself and the Inner value is a padding value added to the tab control. Setting it to 0 will make the tab control border invisible, setting one or all of the left,top,bottom,right values to 0 will make the borders as small as possible.%0a%3c %0a%3c %3cpre>%0a%3c [ClientArea]%0a%3c Left=2%0a%3c Right=2%0a%3c Top=2%0a%3c Bottom=0%0a%3c Inner=1%0a%3c %3c/pre>%0a%3c %0a%3c The WindowFrame section is only valid in FrameLessMode (that is, when you are using your own border and caption bar skinning). It defines the width of the Window border(s) - one value per side and one for the caption bar itself.%0a%3c %0a%3c The other values in this section define the metrics for the title bar buttons - width, height and a top offset and the +CaptionOffset+ defines the top offset for the window icon and the title bar text.%0a%3c %0a%3c %3cpre>%0a%3c [WindowFrame]%0a%3c Left=4%0a%3c Right=4%0a%3c Bottom=4%0a%3c Caption=22%0a%3c ClipFrame=1%0a%3c RadiusTL=6%0a%3c TitleButtonWidth = 12%0a%3c TitleButtonHeight = 12%0a%3c TitleButtonTopOffset = 7%0a%3c CaptionOffset = 6%0a%3c %3c/pre>%0a%3c The next page will answer some common questions, so if things don't work as they should, just read on...%0a%3c %0a%3c %3c!--nextpage-->%0a%3c %0a%3c h3. Skinning the window frame%0a%3c %0a%3c This is a somewhat special case. To skin the window frame, you have to define the following 2 items:%0a%3c %0a%3c * Frame%0a%3c * FrameInactive%0a%3c %0a%3c Of course, you can add image items to these skin definitions like everywhere else. %0a%3c %0a%3c To enable the skinned frame, you need to add:%0a%3c %0a%3c FramelessMode=1%0a%3c %0a%3c to the *[Global]* section. Note that, *both* items (Frame and FrameInactive) *must* be properly defined, because the message window will always use both, depending on the active state of the window. When %25{color:blue}FramelessMode%25 is undefined or set to 0, the frame will appear with the operating systems theme.%0a%3c %0a%3c When using frame skin defintions, you also *HAVE* to define the title buttons, that is, you have to valid skin definitions for the 3 items starting with %25{color:blue}Titlebutton%25. %0a%3c %0a%3c When using image items for the frame, you really *SHOULD* use the %25{color:blue}FillColor%25 statement to speed up drawing of the inner part which will *always* be invisible anyway, because the frame is only a few pixels wide. Adjust the sizing margins of the image items in a way that it will properly stretch on the frame, and then setup the window frame metrics:%0a%3c %0a%3c %3cpre>%0a%3c [WindowFrame]%0a%3c Left=4%0a%3c Right=4%0a%3c Bottom=4%0a%3c Caption=20%0a%3c ClipFrame=1%0a%3c RadiusTL=6%0a%3c %3c/pre>%0a%3c %0a%3c %25{color:blue}Left, Right, Bottom and Caption%25 are the widths (in pixels) for the respective border elemets (Caption = title bar height).%0a%3c %0a%3c %0a%3c h3. Some important things you should know%0a%3c %0a%3c # _Tabs are not accepting the skins, they are still rendered with visual styles, what's wrong?_%0a%3c %25{color:green}You need to disable visual styles on the tab control. To do so, open a container, right click the button bar OR an active tab and choose%25 %25{color:blue}Configure Tab Appearance...%25. %25{color:green}On the following dialog box, you can disable visual styles%25.%0a%3c %0a%3c # _Will it ever be a fully layered skinning engine, compareable to clist_modern?_%0a%3c %25{color:green}Very unlikely. The message windows internals are very different from the contact list. While the contact list draws everything itself, the message window is using standard windows controls to do huge parts of the job. The entire message history is rendered with a rich edit text editor control for example. This wouldn't work very well in a layered environment.%25%0a%3c %25{color:green}Also, IEView would probably never work within a layered message window.%25%0a%3c %3cbr />%0a%3c %0a%3c "Download sample skin":http://miranda.or.at/wp-content/uploads/2006/03/skin.zip%0a%3c %0a%3c [[Category:tabSRMM]]%0a
host:1287786722=81.217.70.206
